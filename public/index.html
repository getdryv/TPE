<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Paiement TPE Simply Permis</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://js.stripe.com/terminal/v1/"></script>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
  <style>
    :root { --brand:#635bff; --bg:#f6f9fc; }
    * { box-sizing: border-box; }
    body {
      font-family: 'Montserrat', sans-serif;
      background-color: var(--bg);
      display: grid;
      place-items: center;
      min-height: 100vh;
      margin: 0;
      padding: 16px;
    }
    .container {
      background: #fff; border-radius: 12px; padding: 28px;
      box-shadow: 0 10px 20px rgba(0,0,0,.08); width: 100%; max-width: 440px;
    }
    h2 { color: var(--brand); margin: 0 0 16px; text-align: center; }
    .row { display: grid; gap: 10px; }
    input, select, button {
      font-family: inherit; font-size: 16px; padding: 12px 14px; border-radius: 8px;
      border: 1px solid #d7dbe7; width: 100%;
    }
    input { background:#edf2ff; }
    button { cursor: pointer; font-weight: 600; border: none; transition: transform .08s ease; }
    button:active { transform: translateY(1px); }
    .main-btn { background: var(--brand); color: #fff; }
    .secondary-btn { background:#fff; color: var(--brand); border:2px solid var(--brand); }
    #status { margin-top: 14px; font-weight: 600; min-height: 24px; }
    .muted { color:#6b7280; font-weight: 500; }
    .hidden { display:none; }
  </style>
</head>
<body>
  <div class="container">
    <h2>Paiement TPE <strong>Simply Permis</strong></h2>

    <div class="row" style="margin-bottom:12px">
      <label class="muted" for="readerSelect">Lecteur d√©tect√©</label>
      <select id="readerSelect"></select>
      <button id="connectBtn" class="secondary-btn hidden">Connecter le lecteur</button>
    </div>

    <form id="paymentForm" class="row" autocomplete="off">
      <input type="text" name="firstName" placeholder="Pr√©nom" required />
      <input type="text" name="lastName"  placeholder="Nom" required />
      <input type="email" name="email"     placeholder="Email" required />
      <input type="text"  name="montant"   placeholder="Montant (‚Ç¨) ‚Äî ex: 12,50" inputmode="decimal" required />
      <button id="payBtn" type="submit" class="main-btn" disabled>Envoyer au TPE</button>
    </form>

    <button id="resetBtn" class="secondary-btn" style="margin-top:10px">Nouvelle transaction</button>
    <div id="status" class="muted"></div>
  </div>

  <script>
    const statusEl = document.getElementById('status');
    const form = document.getElementById('paymentForm');
    const readerSelect = document.getElementById('readerSelect');
    const connectBtn = document.getElementById('connectBtn');
    const resetBtn = document.getElementById('resetBtn');
    const payBtn = document.getElementById('payBtn');

    let terminal;
    let discovered = [];
    let connectedReader = null;

    const PREFERRED_READER_KEY = 'preferred_reader_serial';

    const write = (msg) => {
      statusEl.innerHTML = msg;
      console.log('[TPE]', msg.replace(/<[^>]+>/g, ''));
    };

    async function fetchConnectionToken() {
      const r = await fetch('/connection-token', { method: 'POST' });
      if (!r.ok) throw new Error('Impossible d‚Äôobtenir un connection_token');
      const { secret } = await r.json();
      return secret;
    }

    // 1) Init Terminal + d√©couverte + AUTO-CONNEXION
    async function initTerminal() {
      terminal = StripeTerminal.create({
        onFetchConnectionToken: fetchConnectionToken,
        onUnexpectedReaderDisconnect: () => {
          connectedReader = null;
          payBtn.disabled = true;
          write('‚ùå Lecteur d√©connect√©.');
        }
      });

      write('üîé Recherche des lecteurs (internet)‚Ä¶');
      const res = await terminal.discoverReaders({
        simulated: false,
        discoveryMethod: 'internet'
      });
      if (res.error) return write('‚ùå Erreur d√©couverte lecteur : ' + res.error.message);

      discovered = res.discoveredReaders || [];
      if (!discovered.length) {
        return write('‚ùå Aucun lecteur trouv√©. V√©rifie : cl√©s LIVE, lecteur enregistr√© LIVE, Location assign√©e et r√©seau du lecteur.');
      }

      // Remplir la liste pour info/choix manuel si besoin
      readerSelect.innerHTML = discovered
        .map((r, i) => {
          const label = r.label || r.device_type || r.serial_number || ('Reader #'+(i+1));
          return `<option value="${i}">${label}</option>`;
        }).join('');

      // AUTO-CONNEXION :
      // 1) si un lecteur pr√©f√©r√© est m√©moris√©, tente celui-l√†
      const preferredSerial = localStorage.getItem(PREFERRED_READER_KEY);
      let target = discovered.find(r => r.serial_number === preferredSerial);

      // 2) sinon, si un seul lecteur ‚Üí prends-le
      if (!target && discovered.length === 1) target = discovered[0];

      // 3) sinon, prends celui s√©lectionn√© dans la liste
      if (!target) target = discovered[Number(readerSelect.value || 0)];

      // si on a un candidat, on tente direct la connexion
      if (target) {
        write('üîó Connexion automatique au lecteur‚Ä¶');
        const conn = await terminal.connectReader(target);
        if (conn.error) {
          // si √©chec, on affiche le bouton pour connexion manuelle
          connectBtn.classList.remove('hidden');
          return write('‚ùå Erreur connexion auto : ' + conn.error.message + '<br>Essayez ‚ÄúConnecter le lecteur‚Äù.');
        }
        onReaderConnected(conn.reader);
      } else {
        // pas de cible claire ‚Üí laisse le bouton manuel
        connectBtn.classList.remove('hidden');
        write('‚ÑπÔ∏è S√©lectionnez un lecteur puis cliquez ‚ÄúConnecter le lecteur‚Äù.');
      }
    }

    function onReaderConnected(reader) {
      connectedReader = reader;
      payBtn.disabled = false;
      connectBtn.classList.add('hidden');
      // m√©moriser ce lecteur pour la prochaine fois
      if (reader.serial_number) {
        localStorage.setItem(PREFERRED_READER_KEY, reader.serial_number);
      }
      write('‚úÖ Lecteur connect√© : <b>' + (reader.label || reader.serial_number) + '</b>');
    }

    // Connexion manuelle (fallback)
    connectBtn.addEventListener('click', async () => {
      const idx = Number(readerSelect.value || 0);
      const reader = discovered[idx];
      if (!reader) return write('‚ùå Aucun lecteur s√©lectionn√©.');
      write('üîó Connexion au lecteur‚Ä¶');
      const conn = await terminal.connectReader(reader);
      if (conn.error) return write('‚ùå Erreur connexion : ' + conn.error.message);
      onReaderConnected(conn.reader);
    });

    resetBtn.addEventListener('click', () => location.reload());

    // 3) Paiement
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      if (!connectedReader) return write('‚ùå Connecte un lecteur d‚Äôabord.');

      write('‚è≥ Envoi du paiement‚Ä¶');
      const fd = Object.fromEntries(new FormData(form).entries());

      // Accepter virgule ou point
      const montantFloat = parseFloat(String(fd.montant).replace(',', '.'));
      if (isNaN(montantFloat) || montantFloat <= 0) return write('‚ùå Montant invalide.');
      const amountInCents = Math.round(montantFloat * 100);

      // 3.1 Cr√©er le PaymentIntent c√¥t√© serveur
      const r1 = await fetch('/create-payment-intent', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          montant: amountInCents,
          email: fd.email,
          firstName: fd.firstName,
          lastName: fd.lastName
        })
      });
      const pi = await r1.json();
      if (!r1.ok || !pi.client_secret) {
        return write('‚ùå Erreur cr√©ation PaymentIntent : ' + (pi.error || r1.statusText));
      }

      // 3.2 Collecte sur le lecteur
      write('üí≥ Pr√©sentez la carte‚Ä¶');
      const collect = await terminal.collectPaymentMethod(pi.client_secret);
      if (collect.error) return write('‚ùå Erreur lecture carte : ' + collect.error.message);

      // 3.3 Confirmation (autorisation)
      write('‚úÖ Carte lue. Confirmation‚Ä¶');
      const confirm = await terminal.processPayment(collect.paymentIntent);
      if (confirm.error) return write('‚ùå Erreur confirmation : ' + confirm.error.message);

      // 3.4 Capture c√¥t√© serveur (capture_method: manual)
      write('üîí Capture du paiement‚Ä¶');
      const r2 = await fetch('/capture-payment', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ paymentIntentId: confirm.paymentIntent.id })
      });
      const cap = await r2.json();
      if (!r2.ok || cap.error) return write('‚ùå Erreur capture : ' + (cap.error || r2.statusText));

      write('üéâ Paiement r√©ussi !');
      if (window.confetti) confetti();
    });

    // Lancer l'init au chargement
    initTerminal().catch(e => write('‚ùå Init Terminal : ' + e.message));
  </script>
</body>
</html>
