<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Paiement avec TPE GETdryv</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Stripe Terminal SDK -->
  <script src="https://js.stripe.com/terminal/v1/"></script>
  <!-- Police & confetti (facultatif) -->
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>

  <style>
    :root { --brand:#635bff; --bg:#f6f9fc; }
    * { box-sizing: border-box; }
    body {
      font-family: 'Montserrat', sans-serif;
      background-color: var(--bg);
      display: grid;
      place-items: center;
      min-height: 100vh;
      margin: 0;
      padding: 16px;
    }
    .container {
      background: #fff;
      border-radius: 12px;
      padding: 28px;
      box-shadow: 0 10px 20px rgba(0,0,0,.08);
      width: 100%;
      max-width: 440px;
    }
    h2 { color: var(--brand); margin: 0 0 16px; text-align: center; }
    .row { display: grid; gap: 10px; }
    input, select, button {
      font-family: inherit;
      font-size: 16px;
      padding: 12px 14px;
      border-radius: 8px;
      border: 1px solid #d7dbe7;
      width: 100%;
    }
    input { background:#edf2ff; }
    button {
      cursor: pointer; font-weight: 600; border: none;
      transition: transform .08s ease;
    }
    button:active { transform: translateY(1px); }
    .main-btn { background: var(--brand); color: #fff; }
    .secondary-btn {
      background:#fff; color: var(--brand); border:2px solid var(--brand);
    }
    #status { margin-top: 14px; font-weight: 600; min-height: 24px; }
    .muted { color:#6b7280; font-weight: 500; }
  </style>
</head>
<body>
  <div class="container">
    <h2>Paiement avec TPE <strong>GETdryv</strong></h2>

    <div class="row" style="margin-bottom:12px">
      <label class="muted" for="readerSelect">Lecteur d√©tect√©</label>
      <select id="readerSelect"></select>
      <button id="connectBtn" class="secondary-btn">Connecter le lecteur</button>
    </div>

    <form id="paymentForm" class="row" autocomplete="off">
      <input type="text" name="firstName" placeholder="Pr√©nom" required />
      <input type="text" name="lastName"  placeholder="Nom" required />
      <input type="email" name="email"     placeholder="Email" required />
      <input type="text"  name="montant"   placeholder="Montant (‚Ç¨) ‚Äî ex: 12,50" inputmode="decimal" required />
      <button id="payBtn" type="submit" class="main-btn" disabled>Envoyer au TPE</button>
    </form>

    <button id="resetBtn" class="secondary-btn" style="margin-top:10px">Nouvelle transaction</button>
    <div id="status" class="muted"></div>
  </div>

  <script>
    const statusEl = document.getElementById('status');
    const form = document.getElementById('paymentForm');
    const readerSelect = document.getElementById('readerSelect');
    const connectBtn = document.getElementById('connectBtn');
    const resetBtn = document.getElementById('resetBtn');
    const payBtn = document.getElementById('payBtn');

    let terminal;
    let discovered = [];
    let connectedReader = null;

    const write = (msg) => {
      statusEl.innerHTML = msg;
      console.log('[TPE]', msg.replace(/<[^>]+>/g, ''));
    };

    // 1) Init Terminal + r√©cup√©ration du connection_token depuis ton backend
    async function initTerminal() {
      terminal = StripeTerminal.create({
        onFetchConnectionToken: async () => {
          const r = await fetch('/connection-token', { method: 'POST' });
          if (!r.ok) throw new Error('Impossible d‚Äôobtenir un connection_token');
          const { secret } = await r.json();
          return secret;
        },
        onUnexpectedReaderDisconnect: () => {
          connectedReader = null;
          payBtn.disabled = true;
          write('‚ùå Lecteur d√©connect√©.');
        }
      });

      write('üîé Recherche des lecteurs (internet)‚Ä¶');
      // En prod avec WisePOS E/lecteurs r√©seau
      const res = await terminal.discoverReaders({
        simulated: false,
        discoveryMethod: 'internet'
      });
      if (res.error) return write('‚ùå Erreur d√©couverte lecteur : ' + res.error.message);
      discovered = res.discoveredReaders || [];

      if (!discovered.length) {
        return write('‚ùå Aucun lecteur trouv√©. V√©rifie : cl√©s LIVE, lecteur enregistr√© en LIVE, Location assign√©e et r√©seau du lecteur.');
      }

      // Remplit la liste d√©roulante
      readerSelect.innerHTML = discovered
        .map((r, i) => {
          const label = r.label || r.device_type || r.serial_number || ('Reader #' + (i+1));
          return `<option value="${i}">${label}</option>`;
        })
        .join('');
      write('‚úÖ Lecteur(s) trouv√©(s). S√©lectionne et clique ‚ÄúConnecter le lecteur‚Äù.');
    }

    // 2) Connexion au lecteur choisi
    connectBtn.addEventListener('click', async () => {
      if (!terminal) return write('‚ùå Terminal non initialis√©.');
      const idx = Number(readerSelect.value || 0);
      const reader = discovered[idx];
      if (!reader) return write('‚ùå Aucun lecteur s√©lectionn√©.');

      write('üîó Connexion au lecteur‚Ä¶');
      const conn = await terminal.connectReader(reader);
      if (conn.error) return write('‚ùå Erreur connexion : ' + conn.error.message);

      connectedReader = conn.reader;
      payBtn.disabled = false;
      write('‚úÖ Lecteur connect√© : <b>' + (connectedReader.label || connectedReader.serial_number) + '</b>');
    });

    resetBtn.addEventListener('click', () => location.reload());

    // 3) Soumission du paiement
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      if (!connectedReader) return write('‚ùå Connecte un lecteur d‚Äôabord.');

      write('‚è≥ Envoi du paiement‚Ä¶');
      const fd = Object.fromEntries(new FormData(form).entries());

      // Accepter virgule ou point
      const montantFloat = parseFloat(String(fd.montant).replace(',', '.'));
      if (isNaN(montantFloat) || montantFloat <= 0) return write('‚ùå Montant invalide.');
      const amountInCents = Math.round(montantFloat * 100);

      // 3.1 Cr√©er le PaymentIntent c√¥t√© serveur
      const r1 = await fetch('/create-payment-intent', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          montant: amountInCents,
          email: fd.email,
          firstName: fd.firstName,
          lastName: fd.lastName
        })
      });
      const pi = await r1.json();
      if (!r1.ok || !pi.client_secret) {
        return write('‚ùå Erreur cr√©ation PaymentIntent : ' + (pi.error || r1.statusText));
      }

      // 3.2 Collecte sur le lecteur
      write('üí≥ Pr√©sentez la carte‚Ä¶');
      const collect = await terminal.collectPaymentMethod(pi.client_secret);
      if (collect.error) return write('‚ùå Erreur lecture carte : ' + collect.error.message);

      // 3.3 Confirmation (autorisation)
      write('‚úÖ Carte lue. Confirmation‚Ä¶');
      const confirm = await terminal.processPayment(collect.paymentIntent);
      if (confirm.error) return write('‚ùå Erreur confirmation : ' + confirm.error.message);

      // 3.4 Capture c√¥t√© serveur (car capture_method: manual)
      write('üîí Capture du paiement‚Ä¶');
      const r2 = await fetch('/capture-payment', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ paymentIntentId: confirm.paymentIntent.id })
      });
      const cap = await r2.json();
      if (!r2.ok || cap.error) return write('‚ùå Erreur capture : ' + (cap.error || r2.statusText));

      write('üéâ Paiement r√©ussi !');
      if (window.confetti) confetti();
    });

    // Lancer l'init au chargement
    initTerminal().catch(e => write('‚ùå Init Terminal : ' + e.message));
  </script>
</body>
</html>
